<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Label Frames</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  background: #111; color: #ddd;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  height: 100vh; display: flex; flex-direction: column; overflow: hidden;
  user-select: none;
}

/* ── Header ─────────────────────────────────────────────── */
header {
  padding: 10px 20px; background: #1a1a1a;
  display: flex; justify-content: space-between; align-items: center;
  border-bottom: 1px solid #333;
}
header h1 { font-size: 14px; font-weight: 500; color: #999; }
.header-right { display: flex; align-items: center; gap: 16px; }
.progress-text { font-size: 13px; color: #aaa; }
.progress-bar-wrap {
  width: 200px; height: 8px; background: #333; border-radius: 4px; overflow: hidden;
}
.progress-bar-fill {
  height: 100%; background: #2563eb; border-radius: 4px; transition: width .2s;
}

/* ── Frame viewer ───────────────────────────────────────── */
.viewer {
  flex: 1; display: flex; align-items: center; justify-content: center;
  padding: 16px; min-height: 0; position: relative;
}
.viewer img {
  max-width: 100%; max-height: 100%;
  border: 3px solid #333; border-radius: 4px;
  object-fit: contain;
}
.viewer img.scope       { border-color: #4ade80; }
.viewer img.external    { border-color: #f87171; }
.viewer img.blank       { border-color: #555; }
.viewer img.transitional { border-color: #facc15; }
.viewer img.microscope  { border-color: #4ade80; }

.frame-info {
  position: absolute; bottom: 24px; left: 24px;
  background: rgba(0,0,0,.75); padding: 8px 14px; border-radius: 6px;
  font: 13px/1.6 "SF Mono", Menlo, monospace; color: #ccc;
}
.frame-info .cls { text-transform: uppercase; font-weight: 600; }
.frame-info .cls.scope, .frame-info .cls.microscope { color: #4ade80; }
.frame-info .cls.external    { color: #f87171; }
.frame-info .cls.blank       { color: #777; }
.frame-info .cls.transitional { color: #facc15; }

.label-badge {
  position: absolute; top: 24px; right: 24px;
  padding: 8px 18px; border-radius: 6px;
  font-size: 16px; font-weight: 700; text-transform: uppercase;
  letter-spacing: 1px;
}
.label-badge.scope       { background: rgba(74,222,128,.2); color: #4ade80; border: 2px solid #4ade80; }
.label-badge.external    { background: rgba(248,113,113,.2); color: #f87171; border: 2px solid #f87171; }
.label-badge.blank       { background: rgba(85,85,85,.2); color: #999; border: 2px solid #555; }
.label-badge.transitional { background: rgba(250,204,21,.2); color: #facc15; border: 2px solid #facc15; }
.label-badge.none        { display: none; }

/* ── Bottom panel ───────────────────────────────────────── */
.bottom { background: #1a1a1a; border-top: 1px solid #333; padding: 10px 20px 14px; }

/* Mini timeline */
.timeline {
  height: 24px; background: #222; border-radius: 4px;
  position: relative; cursor: pointer; overflow: hidden;
}
.timeline .tick {
  position: absolute; top: 0; height: 100%;
}
.timeline .tick.scope, .timeline .tick.microscope { background: #4ade80; }
.timeline .tick.external    { background: #f87171; }
.timeline .tick.blank       { background: #666; }
.timeline .tick.transitional { background: #facc15; }
.timeline .tick.unlabeled   { background: #2a2a2a; }
.timeline .playhead {
  position: absolute; top: 0; width: 2px; height: 100%;
  background: white; z-index: 10; pointer-events: none;
}

/* Help + actions */
.bar { display: flex; justify-content: space-between; align-items: center; margin-top: 8px; }
.help { display: flex; gap: 14px; font-size: 12px; color: #666; flex-wrap: wrap; }
kbd {
  background: #333; padding: 1px 5px; border-radius: 3px;
  font-family: "SF Mono", Menlo, monospace; font-size: 11px; color: #aaa;
}
.actions { display: flex; gap: 8px; }
button {
  padding: 7px 16px; border: none; border-radius: 5px;
  font-size: 13px; cursor: pointer; font-weight: 500;
}
.btn-sec { background: #333; color: #ccc; }
.btn-sec:hover { background: #444; }
.btn-sec.active { background: #4b5563; color: white; }

/* Saving indicator */
.save-indicator {
  position: fixed; top: 12px; left: 50%; transform: translateX(-50%);
  background: #2563eb; color: white; padding: 4px 14px; border-radius: 6px;
  font-size: 12px; font-weight: 500; opacity: 0; transition: opacity .2s;
  z-index: 50; pointer-events: none;
}
.save-indicator.show { opacity: 1; }

/* Loading overlay */
.loading {
  position: fixed; inset: 0; background: #111;
  display: flex; align-items: center; justify-content: center;
  font-size: 16px; color: #999; z-index: 100;
}
.loading.hidden { display: none; }
</style>
</head>
<body>

<div class="loading" id="loading">Loading analysis...</div>
<div class="save-indicator" id="save-indicator">Saved</div>

<header>
  <h1 id="title">Label Frames</h1>
  <div class="header-right">
    <span class="progress-text" id="progress-text">Labeled 0 / 0</span>
    <div class="progress-bar-wrap">
      <div class="progress-bar-fill" id="progress-bar" style="width:0%"></div>
    </div>
  </div>
</header>

<div class="viewer">
  <img id="frame" src="" alt="">
  <div class="frame-info">
    <div><span id="info-frame"></span> &nbsp; <span id="info-time"></span></div>
    <div>Auto: <span id="info-auto" class="cls"></span></div>
  </div>
  <div class="label-badge none" id="label-badge"></div>
</div>

<div class="bottom">
  <div class="timeline" id="timeline"></div>
  <div class="bar">
    <div class="help">
      <span><kbd>&larr;</kbd><kbd>&rarr;</kbd> navigate</span>
      <span><kbd>Shift</kbd>+arrows jump 10</span>
      <span><kbd>E</kbd> external</span>
      <span><kbd>S</kbd> scope</span>
      <span><kbd>B</kbd> blank</span>
      <span><kbd>T</kbd> transitional</span>
      <span><kbd>U</kbd> unlabel</span>
    </div>
    <div class="actions">
      <button class="btn-sec" id="btn-skip">Skip labeled: ON</button>
      <button class="btn-sec" id="btn-back"><a href="/" style="color:inherit;text-decoration:none;">Back to editor</a></button>
    </div>
  </div>
</div>

<script>
// ── State ────────────────────────────────────────────────────────────────────
let data = null;
let labels = {};          // { "1": "scope", "2": "external", ... } keyed by thumb number string
let thumbInterval, thumbCount, duration;
let skipLabeled = true;
let filtered = [];        // thumb indices visible in current filter
let pos = 0;              // index into filtered[]
let saveTimeout = null;
let dirty = false;

// ── Init ─────────────────────────────────────────────────────────────────────
async function init() {
  const [analysisResp, labelsResp] = await Promise.all([
    fetch("/api/analysis"),
    fetch("/api/labels"),
  ]);
  data = await analysisResp.json();
  labels = await labelsResp.json();

  thumbInterval = data.thumb_interval;
  thumbCount = data.thumb_count;
  duration = data.duration;

  document.getElementById("title").textContent =
    "Label: " + data.video_path.split("/").pop();

  updateFiltered();
  renderTimeline();
  updateProgress();
  document.getElementById("loading").classList.add("hidden");
  go(0);
}

// ── Helpers ──────────────────────────────────────────────────────────────────
function fmt(sec) {
  const h = Math.floor(sec / 3600);
  const m = Math.floor((sec % 3600) / 60);
  const s = Math.floor(sec % 60);
  return h ? `${h}:${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`
           : `${m}:${String(s).padStart(2,"0")}`;
}

function thumbTime(n) { return (n - 1) * thumbInterval; }

function segmentAt(t) {
  return data.segments.find(s => t >= s.start && t < s.end);
}

function autoClassAt(n) {
  const seg = segmentAt(thumbTime(n));
  return seg ? seg.classification : "blank";
}

// ── Filtered index ───────────────────────────────────────────────────────────
function updateFiltered() {
  filtered = [];
  for (let i = 1; i <= thumbCount; i++) {
    if (!skipLabeled || !labels[String(i)]) {
      filtered.push(i);
    }
  }
  // If everything is labeled and we're skipping, show all instead
  if (filtered.length === 0 && skipLabeled) {
    for (let i = 1; i <= thumbCount; i++) filtered.push(i);
  }
}

// ── Navigation ───────────────────────────────────────────────────────────────
function go(idx) {
  if (!filtered.length) return;
  pos = Math.max(0, Math.min(idx, filtered.length - 1));

  const n = filtered[pos];
  const t = thumbTime(n);
  const autoCls = autoClassAt(n);
  const lbl = labels[String(n)] || null;

  const img = document.getElementById("frame");
  img.src = `/api/thumb/${n}`;
  img.className = lbl || autoCls;

  document.getElementById("info-frame").textContent = `Frame ${n} / ${thumbCount}`;
  document.getElementById("info-time").textContent = fmt(t);

  const autoEl = document.getElementById("info-auto");
  autoEl.textContent = autoCls;
  autoEl.className = "cls " + autoCls;

  const badge = document.getElementById("label-badge");
  if (lbl) {
    badge.textContent = lbl;
    badge.className = "label-badge " + lbl;
  } else {
    badge.className = "label-badge none";
  }

  // Move playhead
  const ph = document.querySelector(".playhead");
  if (ph) ph.style.left = `${(t / duration) * 100}%`;

  // Preload neighbors
  for (let d = -3; d <= 3; d++) {
    const j = pos + d;
    if (j >= 0 && j < filtered.length && j !== pos) {
      new Image().src = `/api/thumb/${filtered[j]}`;
    }
  }
}

// ── Labeling ─────────────────────────────────────────────────────────────────
function applyLabel(cls) {
  if (!filtered.length) return;
  const n = filtered[pos];
  labels[String(n)] = cls;
  dirty = true;
  scheduleSave();
  updateProgress();
  renderTimeline();

  // Auto-advance: move to next unlabeled if skip mode is on
  if (skipLabeled) {
    const prevN = n;
    updateFiltered();
    // Find the next frame after current
    let best = 0, bestDist = Infinity;
    for (let i = 0; i < filtered.length; i++) {
      const d = filtered[i] - prevN;
      // Prefer the first frame AFTER the one just labeled
      if (d > 0 && d < bestDist) { bestDist = d; best = i; }
    }
    // If nothing after, go to nearest
    if (bestDist === Infinity) {
      for (let i = 0; i < filtered.length; i++) {
        const d = Math.abs(filtered[i] - prevN);
        if (d < bestDist) { bestDist = d; best = i; }
      }
    }
    go(best);
  } else {
    go(pos);  // refresh display in place
  }
}

function removeLabel() {
  if (!filtered.length) return;
  const n = filtered[pos];
  delete labels[String(n)];
  dirty = true;
  scheduleSave();
  updateProgress();
  renderTimeline();
  go(pos);
}

// ── Save ─────────────────────────────────────────────────────────────────────
function scheduleSave() {
  if (saveTimeout) clearTimeout(saveTimeout);
  saveTimeout = setTimeout(doSave, 500);
}

async function doSave() {
  if (!dirty) return;
  dirty = false;
  try {
    await fetch("/api/labels", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify(labels),
    });
    const indicator = document.getElementById("save-indicator");
    indicator.classList.add("show");
    setTimeout(() => indicator.classList.remove("show"), 800);
  } catch (e) {
    console.error("Save failed:", e);
    dirty = true;  // retry
  }
}

// ── Progress ─────────────────────────────────────────────────────────────────
function updateProgress() {
  const count = Object.keys(labels).length;
  document.getElementById("progress-text").textContent =
    `Labeled ${count} / ${thumbCount}`;
  document.getElementById("progress-bar").style.width =
    `${thumbCount ? (count / thumbCount * 100) : 0}%`;
}

// ── Timeline ─────────────────────────────────────────────────────────────────
function renderTimeline() {
  const tl = document.getElementById("timeline");
  tl.innerHTML = "";

  const tickW = 100 / thumbCount;
  for (let i = 1; i <= thumbCount; i++) {
    const div = document.createElement("div");
    const lbl = labels[String(i)];
    let cls;
    if (lbl) {
      cls = lbl;
    } else {
      cls = "unlabeled";
    }
    div.className = `tick ${cls}`;
    div.style.left = `${(i - 1) * tickW}%`;
    div.style.width = `${tickW + 0.1}%`;  // tiny overlap to avoid gaps
    tl.appendChild(div);
  }

  const ph = document.createElement("div");
  ph.className = "playhead";
  tl.appendChild(ph);
}

// ── Skip toggle ──────────────────────────────────────────────────────────────
function toggleSkip() {
  skipLabeled = !skipLabeled;
  const prevThumb = filtered.length ? filtered[pos] : 1;
  updateFiltered();

  document.getElementById("btn-skip").textContent =
    skipLabeled ? "Skip labeled: ON" : "Skip labeled: OFF";
  document.getElementById("btn-skip").classList.toggle("active", !skipLabeled);

  let best = 0, bestDist = Infinity;
  for (let i = 0; i < filtered.length; i++) {
    const d = Math.abs(filtered[i] - prevThumb);
    if (d < bestDist) { bestDist = d; best = i; }
  }
  go(best);
}

// ── Keyboard ─────────────────────────────────────────────────────────────────
document.addEventListener("keydown", e => {
  if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA") return;

  switch (e.key) {
    case "ArrowRight": e.preventDefault(); go(pos + (e.shiftKey ? 10 : 1)); break;
    case "ArrowLeft":  e.preventDefault(); go(pos - (e.shiftKey ? 10 : 1)); break;
    case "e": case "E": e.preventDefault(); applyLabel("external"); break;
    case "s": case "S": e.preventDefault(); applyLabel("scope"); break;
    case "b": case "B": e.preventDefault(); applyLabel("blank"); break;
    case "t": case "T": e.preventDefault(); applyLabel("transitional"); break;
    case "u": case "U": e.preventDefault(); removeLabel(); break;
  }
});

// ── Click handlers ───────────────────────────────────────────────────────────
document.getElementById("timeline").addEventListener("click", e => {
  const rect = e.currentTarget.getBoundingClientRect();
  const frac = (e.clientX - rect.left) / rect.width;
  const targetN = Math.round(frac * thumbCount) + 1;

  let best = 0, bestDist = Infinity;
  for (let i = 0; i < filtered.length; i++) {
    const d = Math.abs(filtered[i] - targetN);
    if (d < bestDist) { bestDist = d; best = i; }
  }
  go(best);
});

document.getElementById("btn-skip").addEventListener("click", toggleSkip);

// Save on page exit
window.addEventListener("beforeunload", () => { if (dirty) doSave(); });

// ── Go ───────────────────────────────────────────────────────────────────────
init();
</script>
</body>
</html>
